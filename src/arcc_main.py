#!/usr/bin/env python3
import argparse
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Optional, ClassVar, TYPE_CHECKING, List, Tuple, Callable

if TYPE_CHECKING:
    from src.consumption import AssignmentHandler
    from src.search import SearchStrategy
    from src.assignment import Assignment
    from src.production import Config

logger_init = False


def get_logger() -> logging.Logger:
    """
    Make sure the logger has been initialized first before calling this!
    """
    return logging.getLogger('arcc')


def initialize_logger(log_file: Optional[str], verbose: bool):
    """
    Build and return the `arcc` logger. Should only be called once! After
    called, can also be accessed with logging.getLogger('arcc').
    """
    global logger_init
    if logger_init:
        return
    logger_init = True
    # high level logger - for now, no others are used
    logger = logging.getLogger('arcc')
    # custom formatter
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
    # DEBUG for verbose, otherwise just info
    log_level = logging.DEBUG if verbose else logging.INFO
    # log level must be set for both
    logger.setLevel(log_level)

    # helper to configure a handler
    def configure_handler(handler):
        handler.setLevel(log_level)
        handler.setFormatter(formatter)
        logger.addHandler(handler)

    # file handler
    if log_file is not None:
        configure_handler(logging.FileHandler(log_file))
    # stream (stdout) handler
    configure_handler(logging.StreamHandler())
    logger.debug("created logger")
    return logger


def get_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description='ARCC is an automated tuning tool designed to tune '
                    'compiler flags for optimal performance.')
    # argfile group - either the classic or the new format
    argfile = parser.add_mutually_exclusive_group()
    argfile.add_argument("--argfile-classic",
                         help="argument file that uses the previous format, as "
                              "generated by R-Stream. See README for more info")
    argfile.add_argument("--argfile",
                         help="argument file with tunable args, and "
                              "optionally build/run commands. See README "
                              "for more info.")
    # clean build and run command
    parser.add_argument('--clean', required=True,
                        help="clean command. ran before building.")
    parser.add_argument('--build', required=True,
                        help="build command. use {VAR_NAME} to indicate where "
                             "variables should be placed in the command.")
    parser.add_argument('--run', required=True,
                        help="run command. will be run after building and "
                             "timed. this is the main command to test")
    # logging stuff
    parser.add_argument('--verbose', help="enable verbose logging",
                        action='store_true')
    parser.add_argument('--log-file', help="log file location",
                        # with just --log-file, stored in log.txt
                        action='store_const', const="log.txt")
    # iterations
    parser.add_argument('--max-iter', '-n', type=int,
                        help="max number of iterations in the search "
                             "(infinite by default)")
    # output folder
    curr_time = str(datetime.now()).replace(' ', '_')
    default_output = os.path.join("arcc-codes", f"arcc-run-{curr_time}")
    parser.add_argument('--output', help="output location",
                        default=default_output)
    # files to copy to our own directory
    parser.add_argument('--preserve', help="files to preserve in our local dir",
                        nargs="+")
    # whether to switch to a fresh directory to run our command
    parser.add_argument('--fresh-dir',
                        help="switch to a fresh directory to run our command",
                        action='store_true')

    # exclusive group of search strategies
    strategy_group = parser.add_mutually_exclusive_group()
    strategy_group.add_argument("--dummy", action="store_true",
                                help="dummy strategy that executes once with "
                                     "arbitrary arguments, useful for testing")
    strategy_group.add_argument("--random", action="store_true",
                                help="simple strategy that randomly varies "
                                     "arguments and returns the best one")
    strategy_group.add_argument("--mutation", action="store_true",
                                help="strategy that repeatedly mutates the "
                                     "best known assignment until satisfied")
    return parser


def programmatic_main(clean: Callable[[], None],
                      build: Callable[[], None],
                      run: Callable[[], Optional[float]],
                      argfile: Optional[Path] = None,
                      search_class: ClassVar[Optional["SearchStrategy"]] = None,
                      max_iter: Optional[int] = None,
                      out_dir: Optional[Path] = None,
                      preserve: Optional[List[Path]] = None,
                      enable_logging: bool = True) -> \
        (Optional[Tuple["Assignment", Path]]):
    """
    A "programmatic" frontend to arcc. Rather than specifying clean, build, and
    run commands, the user can specify python functions to be called.
    @param clean: callback for cleaning
    @param build: callback for building
    @param run: callback for running
    @param argfile: path to input argfile, or none for R-Stream generation
    @param search_class: search class to use, or none for mutation
    @param max_iter: max iterations, or none for unbounded
    @param out_dir: path to output dir, or None for arcc to choose
    @param preserve: list of paths of files to preserve after building
    @param enable_logging: whether to enable logging
    @return: optimal assignment and path to run dir, or none if none found
    """
    from src.production import Config
    from src.consumption import PythonFuncHandler
    from src.production import NewArgFile, RstreamArgFile
    from src.search import MutationSearch, RandomSearch
    if enable_logging:
        initialize_logger(None, False)
    # initialize defaults for all the user variables if unspecified
    if not argfile:
        argfile = RstreamArgFile()
    else:
        argfile = NewArgFile(argfile)

    if not search_class:
        search_class = RandomSearch

    if not out_dir:
        curr_time = str(datetime.now()).replace(' ', '_')
        out_dir = Path(os.path.join("arcc-codes", f"arcc-run-{curr_time}"))

    if not preserve:
        preserve = []

    assignment_handler = PythonFuncHandler(clean, build, run)
    if search_class is None:
        search_class = MutationSearch
    # build the config, call the inner main
    config = Config(max_iter, out_dir, preserve, search_class)
    return main_inner(assignment_handler, config, argfile)


def main():
    """
    the main called from the command line. Ideally, this would be unified, with
    the programmatic_main frontend, so both are essentially doing the same
    thing. However, there is some subtlety when handling e.g. defaults that make
    it a bit tricky.
    """
    from src.production import Config
    from src.consumption import DefaultHandler
    from src.search import DummySearch, RandomSearch, MutationSearch
    from src.production import NewArgFile, RstreamArgFile, ClassicArgFile

    # parse the command line
    parser = get_arg_parser()
    args = parser.parse_args()

    assignment_handler = \
        DefaultHandler(args.fresh_dir, args.clean, args.build, args.run)

    # choose the search strategy class
    if args.dummy:
        search_strategy = DummySearch
    elif args.random:
        search_strategy = RandomSearch
    elif args.mutation:
        search_strategy = MutationSearch
    else:
        get_logger().info("defaulting to mutation search strategy")
        search_strategy = MutationSearch
    # initialize the logger
    initialize_logger(args.log_file, args.verbose)
    if not args.preserve:
        args.preserve = []
    config = Config(args.max_iter, Path(args.output),
                    [Path(file) for file in args.preserve],
                    search_strategy)
    if args.argfile_classic:
        argfile = ClassicArgFile(Path(args.argfile_classic))
    elif args.argfile:
        argfile = NewArgFile(Path(args.argfile))
    else:
        argfile = RstreamArgFile()
    # call the inner main
    main_inner(assignment_handler, config, argfile)


def main_inner(assignment_handler: "AssignmentHandler",
               config: "Config", argfile) -> \
        (Optional[Tuple["Assignment", Path]]):
    """
    main logic shared by both frontends
    @param assignment_handler: backend for evaluating assignments
    @param config: configuration file
    @param argfile: argument file
    @return: optimal assignment, path to assignment dir
    """
    # delay the imports until necessary, in case they depend on this module
    from src.production import production
    from src.consumption import consumption
    # produce, then consume
    root = production(assignment_handler, argfile, config.output)
    return consumption(config, root, assignment_handler)

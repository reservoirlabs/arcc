#!/usr/bin/env python3
import argparse
import logging
import os
from datetime import datetime
from typing import Optional, Any


def get_logger() -> logging.Logger:
    """
    Make sure the logger has been initialized first before calling this!
    """
    return logging.getLogger('arcc')


def initialize_logger(log_file: Optional[str], verbose: bool):
    """
    Build and return the `arcc` logger. Should only be called once! After
    called, can also be accessed with logging.getLogger('arcc').
    """
    # high level logger - for now, no others are used
    logger = logging.getLogger('arcc')
    # custom formatter
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
    # DEBUG for verbose, otherwise just info
    log_level = logging.DEBUG if verbose else logging.INFO
    # log level must be set for both
    logger.setLevel(log_level)

    # helper to configure a handler
    def configure_handler(handler):
        handler.setLevel(log_level)
        handler.setFormatter(formatter)
        logger.addHandler(handler)

    # file handler
    if log_file is not None:
        configure_handler(logging.FileHandler(log_file))
    # stream (stdout) handler
    configure_handler(logging.StreamHandler())
    logger.debug("created logger")
    return logger


def parse_args() -> Any:
    """
    Parse args and return the result.
    """
    parser = argparse.ArgumentParser(
        description='ARCC is an automated tuning tool designed to tune '
                    'compiler flags for optimal performance.')
    # config group - either the legacy or the new format
    config = parser.add_mutually_exclusive_group()
    config.add_argument("--config-classic",
                        help="config with the previous format, as generated by "
                             "R-Stream. See README for more info.")
    config.add_argument("--config",
                        help="configuration file with tunable args, and "
                             "optionally build/run commands. See README "
                             "for more info.")
    # clean build and run command
    parser.add_argument('--clean',
                        help="clean command. ran before building.")
    parser.add_argument('--build',
                        help="build command. use {VAR_NAME} to indicate where "
                             "variables should be placed in the command.")
    parser.add_argument('--run',
                        help="run command. will be run after building and "
                             "timed. this is the main command to test")
    # logging stuff
    parser.add_argument('--verbose', help="enable verbose logging",
                        action='store_true')
    parser.add_argument('--log-file', help="log file location",
                        # with just --log-file, stored in log.txt
                        action='store_const', const="log.txt")
    # iterations
    parser.add_argument('--max-iter', '-n', type=int,
                        help="max number of iterations in the search "
                             "(infinite by default)")
    # output folder
    curr_time = str(datetime.now()).replace(' ', '_')
    default_output = os.path.join("arcc-codes", f"arcc-run-{curr_time}")
    parser.add_argument('--output', help="output location",
                        default=default_output)
    # files to copy to our own directory
    parser.add_argument('--preserve', help="files to preserve in our local dir",
                        nargs="+")
    # whether to switch to a fresh directory to run our command
    parser.add_argument('--fresh-dir',
                        help="switch to a fresh directory to run our command",
                        action='store_true')

    # exclusive group of search strategies
    strategy_group = parser.add_mutually_exclusive_group()
    strategy_group.add_argument("--dummy", action="store_true",
                                help="dummy strategy that executes once with "
                                     "arbitrary arguments, useful for testing")
    strategy_group.add_argument("--random", action="store_true",
                                help="simple strategy that randomly varies "
                                     "arguments and returns the best one")
    strategy_group.add_argument("--mutation", action="store_true",
                                help="strategy that repeatedly mutates the "
                                     "best known assignment until satisfied")

    return parser.parse_args()


def main():
    # delay the imports until necessary, in case they depend on this module
    from src.production import production
    from src.consumption import consumption
    args = parse_args()
    initialize_logger(args.log_file, args.verbose)
    config = production(args)
    consumption(config)

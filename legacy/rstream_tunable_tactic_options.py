# DOE-GPU rights
#
# Author      : Albert Hartono <hartonoa@reservoir.com>
# Description : Concrete class for R-Stream tunable tactic options
#
# $Id$
#

import os, subprocess
from legacy import tunable_tactic_options


#----------------------------------------------------------

class RStreamTunableTacticOptions(tunable_tactic_options.TunableTacticOptions):
    '''The concrete class for R-Stream tunable tactic options'''

    # List of excluded tactic options
    __NOT_TUNED_TACTIC_OPTIONS = [('placetile','sizes'), ('decpltile','sizes')]

    # ARCC environment variable name
    __ARCC_OPTIONFILE = 'ARCC_OPTIONFILE'

    # Tactic options file name
    __OPTION_FNAME = 'arcc-tactic-options.dat'

    # Commands used to query RStream
    __RCC_TEST_CMD = 'rcc --help'
    __RCC_LIST_TACTIC_OPTS_CMD = 'rcc -S -fopenmp --map:list-autotunable %s'

    #------------------------------------------------------

    def __init__(self, reporter):
        '''Instantiate a R-Stream tunable tactic options instance'''
        
        super(RStreamTunableTacticOptions, self).__init__(reporter)
        
        self.__all_tactic_options_descriptions = None

    #------------------------------------------------------

    def __runShellCmd(self, cmd):
        '''Run the given shell command and return the exit status and output'''

        p = subprocess.Popen([cmd], shell=True, executable="bash", close_fds=True,
                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
        output = p.communicate()[0].rstrip()
        status = p.returncode
        return (status, output)

    #------------------------------------------------------
    
    def __createDummyCFile(self):
        '''Create a dummy C file used as RStream input'''
        
        # The content of the dummy C file
        content = ''
        content += '\n'
        content += 'float A[100]; float B[100]; \n'
        content += '\n'
        content += '#pragma rstream map \n'
        content += 'void foo() { \n'
        content += '  int i; \n'
        content += '  for (i=0; i<100; i++) {\n'
        content += '    A[i] += B[i]; \n'
        content += '  }\n'
        content += '} \n'
        content += '\n'
        
        # Create the filename
        fname = os.path.join(os.path.abspath(os.curdir), '%s-dummy-code.c' % self.reporter.moduleName())
        
        # Create the file and write the C code
        try:
            f = open(fname, 'w')
            f.write(content)
            f.close()
        except Exception as e:
            raise self.reporter.error('Failed to create the dummy C file for RStream: %s. \n' % fname)
        
        # Return the filename
        return fname
    
    #------------------------------------------------------

    def __deleteDummyCFileRCCFiles(self, fname):
        '''Delete the dummy C file and new files generated by RStream'''

        # Delete the dummy C file
        os.unlink(fname)
        
        # Delete the new files (i.e., the name has the same prefix as the dummy C filename)
        prefix = os.path.basename(fname).split('.')[0]
        for _, _, files in os.walk(os.curdir):
            for f in files:
                if f.startswith(prefix):
                    os.unlink(f)
            break

    #------------------------------------------------------

    def __filterTacticOptions(self, exclude_list, tactic_options_descriptions):
        '''To exclude some tactic options from the given list of tactic options'''
        
        for et, eo in exclude_list:
            n_list = []
            for t, o, u, d in tactic_options_descriptions:
                if (et != '*' and et != t) or (eo != '*' and eo != o):
                    n_list.append((t, o, u, d))
            tactic_options_descriptions = n_list
        return tactic_options_descriptions

    #------------------------------------------------------

    def listTunableTacticOptions(self):
        '''
        Return a list of R-Stream's tunable tactic options (along with
        their short descriptions)
        '''

        # Query RStream to get a list of all tunable tactic options
        if self.__all_tactic_options_descriptions == None:

             # Print some opening messages
            self.reporter.logMessage('Query RStream for a list of all autotunable tactic options')
            
            # Test RStream
            self.reporter.logMessage('Test RStream: "%s"' % self.__RCC_TEST_CMD)
            status, output = self.__runShellCmd(self.__RCC_TEST_CMD)
            if status == 0:
                self.reporter.logMessage('RStream test successful.')
            else:
                raise self.reporter.error(('Failed to test running RCC: "%s". \n' +
                                           'Please check if RStream is properly installed. \n' +
                                           'Dump error message: \n%s') % (self.__RCC_TEST_CMD, output))

            # Create a dummy C file for RStream
            dummy_c_fname = self.__createDummyCFile()

            # Set environment variable to tell RCC where to write the
            # queried tactic options list
            self.reporter.logMessage('Sets environment variables: ')
            opt_fname = os.path.join(os.path.abspath(os.curdir), self.__OPTION_FNAME)
            self.reporter.logMessage('  %s=%s ' % (self.__ARCC_OPTIONFILE, opt_fname))
            os.environ[self.__ARCC_OPTIONFILE] = opt_fname

            # Query RStream
            rstream_cmd = self.__RCC_LIST_TACTIC_OPTS_CMD % dummy_c_fname
            self.reporter.logMessage('Query RStream: "%s"' % rstream_cmd)
            status, output = self.__runShellCmd(rstream_cmd)

            # Flush environment variable
            self.reporter.logMessage('Flushes environment variables: %s' % self.__ARCC_OPTIONFILE)
            del os.environ[self.__ARCC_OPTIONFILE]
            
            # Delete the dummy C file and new files generated by RStream
            self.__deleteDummyCFileRCCFiles(dummy_c_fname)

            # Check for errors
            if status != 0 or not os.path.exists(opt_fname):
                raise self.reporter.error(('Failed to query RCC for a list of autotunable tactic options: "%s" \n' +
                                           'Please report this error to rstream-support@reservoir.com. \n' +
                                           'Dump error message: %s\n%s') % (rstream_cmd, rstream_cmd, output))

            # Read the tactic option file
            self.reporter.logMessage('Read the list of all autotunable tactic options from file: %s' % opt_fname)
            try:
                f = open(opt_fname, 'r')
                text = f.read()
                f.close()
            except Exception as e:
                raise self.reporter.error('Failed to read tactic option file generated by RCC: %s' % opt_fname)
            
            # Delete the tactic option file
            os.unlink(opt_fname)

            # Evaluate the list of all tunable tactic options
            try:
                tactic_options_descriptions = eval('%s' % text)
            except Exception as e:
                print(e)
                raise self.reporter.error('Unable to parse text in tactic option file: \n %s' % text)
            is_invalid = False
            if not (isinstance(tactic_options_descriptions, list) or isinstance(tactic_options_descriptions, tuple)):
                is_invalid = True
            else:
                for tup in tactic_options_descriptions:
                    if not (isinstance(tup, list) or isinstance(tup, tuple)) or len(tup) != 4:
                        is_invalid = True
                        break
                    for e in tup:
                        if not isinstance(e, str):
                            is_invalid = True
                            break
                    if is_invalid:
                        break
            if is_invalid:
                raise self.reporter.error('Invalid form of autotunable tactic options: \n %s' % text)

            # Filter tactic options
            tactic_options_descriptions = self.__filterTacticOptions(self.__NOT_TUNED_TACTIC_OPTIONS, tactic_options_descriptions)

            # Remember the list of all tunable tactic options (with their descriptions)
            self.__all_tactic_options_descriptions = tactic_options_descriptions

            # Print the obtained tunable tactic options
            s = ''
            s += 'List of all autotunable tactic options: \n'
            for t, o, u, d in tactic_options_descriptions:
                s += '  tactic=%s, option=%s, used by default=%s, description=%s \n' % (t, o, u, d)
            self.reporter.logMessage(s)

        # Return all tunable tactic options (with their descriptions)
        return self.__all_tactic_options_descriptions

